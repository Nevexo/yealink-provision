// Express Router for managing sites

import { Router } from 'express';
import { Site } from '../mongo/schemas/site.js';
import { customAlphabet } from 'nanoid';
import { logger } from '../index.js';

import { Device } from '../mongo/schemas/device.js';

// Setup nanoid
const nanoid = customAlphabet('1234567890abcdef', 8);

const router = Router();

// Get all sites
router.get('/', async (req, res) => {
  const sites = await Site.find();
  res.json(sites);
});

// Get a specific site
router.get('/:id', async (req, res) => {
  const site = await Site.findOne({ id: req.params.id });
  if (!site) {
    res.status(404).json({
      error: 'Not Found',
      message: `Site not found`,
    })
    return;
  }
  
  res.json(site);
});

// Create a new site
router.post('/', async (req, res) => {
  // Verify required elements are present, except ID which is generated by nanoid.
  if (!req.body.name) {
    res.status(400).json({
      error: 'Bad Request',
      message: 'The request body must contain a name property.',
    })
    return;
  }

  // Generate a new ID
  req.body.id = nanoid(4);
  
  // Generate a password - TODO: this is a temporary measure until authentication is figured out with Yealink devices.
  req.body.password = nanoid(16);

  // Create the new site
  const site = new Site(req.body);
  await site.save();

  logger.info(`Created new site ${site.id} (${site.name})`)

  res.json(site);
});

// Enable a site
router.post('/:id/enable', async (req, res) => {
  const site = await Site.findOne({ id: req.params.id });
  if (!site) {
    res.status(404).json({
      error: 'Not Found',
      message: `Site not found`,
    })
    return;
  }

  if (site.enable) {
    res.status(400).json({
      error: 'site_already_enabled',
      message: `Site is already enabled`,
    })
    return;
  }

  site.enable = true;
  await site.save();

  res.json({
    status: "site_enabled",
    message: "Site has been enabled successfully."
  })

  logger.info(`Enabled site ${site.id} (${site.name})`)
});

// Disable a site
router.delete('/:id/enable', async (req, res) => {
  const site = await Site.findOne({ id: req.params.id });
  if (!site) {
    res.status(404).json({
      error: 'site_not_found',
      message: `Site not found`,
    })
    return;
  }

  if (!site.enable) {
    res.status(400).json({
      error: 'site_not_enabled',
      message: `Site is not enabled.`,
    })
    return;
  }

  site.enable = false;
  await site.save();

  res.json({
    status: "site_disabled",
    message: "Site has been disabled successfully."
  })

  logger.info(`Disabled site ${site.id} (${site.name})`)
});

// Rename site
router.patch('/:id', async (req, res) => {
  const site = await Site.findOne({ id: req.params.id });
  if (!site) {
    res.status(404).json({
      error: 'Not Found',
      message: `Site not found`,
    })
    return;
  }

  if (req.body.name) {
    site.name = req.body.name;
  }

  await site.save();
  res.json(site);

  logger.info(`Renamed site ${site.id} (${site.name})`)
});

// Delete a site
router.delete('/:id', async (req, res) => {
  const site = await Site.findOne({ id: req.params.id });
  if (!site) {
    res.status(404).json({
      error: 'Not Found',
      message: `Site not found`,
    })
    return;
  }

  // Check for devices
  const devices = await Device.find({ site_id: req.params.id });
  if (devices.length > 0) {
    res.status(400).json({
      error: 'site_has_devices',
      message: `This site has devices, they must be deleted first.`,
    })
    return;
  }

  // Check for any config groups targeting this site
  const configGroups = await ConfigGroup.find({ target_type: "site", target_id: req.params.id });
  if (configGroups.length > 0) {
    res.status(400).json({
      error: 'site_has_config_groups',
      message: `This site has config groups, they must be deleted first.`,
    })
    return;
  }

  await Site.deleteOne({ id: req.params.id })

  res.json({
    status: "site_deleted",
    message: "Site has been deleted successfully."
  })

  logger.info(`Deleted site ${site.id} (${site.name})`)
});

export default router;